import debug from "debug";
import { v4 as uuid } from "uuid";
/**
 * Add structure to the postmessage channel by defining message types
 * and listening for specific streams based on engine name and window.
 */
export default class PostMessageEngine {
    /** The name of the engine. The engine will only listen for events sent to this name. */
    name;
    /** The name of the engine to send messages to. */
    _targetName;
    /** The window to send and receive messages to. Defaults to current window. */
    _targetWindow;
    /** Listen for messages from just target window or all windows if disabled. Defaults to true.*/
    _targetWindowFilter;
    /** Origin to send and receive messages on. Security backstop, be careful of using '*'. Defaults to current origin. */
    _targetOrigin;
    _listeners = {};
    _logger;
    constructor(options) {
        this.name = options.name;
        this._targetName = options.targetName;
        this._targetWindow = options.targetWindow || window;
        this._targetWindowFilter = options.targetWindowFilter ?? true;
        this._targetOrigin = options.targetOrigin || window.location.origin;
        this._logger = debug("mash:post-message");
        // debug logging can be enabled with env var or by the consumer
        this._logger.enabled = this._logger.enabled || (options.debug ?? false);
    }
    /**
     * Check to determine if message should be ignore. PostMessage listener can be polluted with
     * external message. This filter creates a "stream" that only processes events between 2 targets.
     */
    // @ts-ignore Type 'MessageEvent' is not generic
    _shouldIgnoreMessage(evt) {
        // origin is the main security check
        if (this._targetOrigin !== "*" && evt.origin !== this._targetOrigin) {
            this._logger(`${this.name} engine ignored message due to origin, message: ${evt.origin} engine: ${this._targetOrigin}`);
            return true;
        }
        const message = evt.data;
        const messageIsObject = typeof message === "object";
        if (!messageIsObject) {
            this._logger(`${this.name} engine ignored message due to not an object`);
            return true;
        }
        // engine name's define streams
        if (messageIsObject && message.targetName !== this.name) {
            this._logger(`${this.name} engine ignored message due to target name, message: ${message.targetName} engine: ${this.name}`);
            return true;
        }
        // checking the event source helps limit messages and can also be used as a secondary security check
        if (this._targetWindowFilter && this._targetWindow !== evt.source) {
            this._logger(`${this.name} engine ignored message due to window, message: ${evt.source} engine: ${this._targetWindow}`);
            return true;
        }
        if (messageIsObject && !message.data) {
            this._logger(`${this.name} engine ignored message due to no data`);
            return true;
        }
        // do not ignore message
        return false;
    }
    // Attaches a listener to the window to listen on 'message' events.
    _listen(listener, id) {
        // @ts-ignore Type 'MessageEvent' is not generic
        const wrapped = (evt) => {
            if (this._shouldIgnoreMessage(evt))
                return;
            listener(evt.data || null);
        };
        this._listeners[id] = wrapped;
        window.addEventListener("message", wrapped, false);
        return () => this.unsubscribe(id);
    }
    /**
     * Unsubscribe listener.
     * @param id of listener
     */
    unsubscribe(id) {
        const listener = this._listeners[id];
        if (listener) {
            window.removeEventListener("message", listener);
            delete this._listeners[id];
        }
    }
    /**
     * Sends a message using targetWindow.
     * @param data to send through post message
     */
    send(data) {
        this._targetWindow.postMessage({
            targetName: this._targetName,
            data,
        }, this._targetOrigin);
    }
    /**
     * Attach a listener to events sent to engine.
     * @param callback to process event
     * @returns fn to unsubscribe listener
     */
    listen(callback) {
        return this._listen(callback, uuid());
    }
    /**
     * Remove all event listeners.
     */
    destroy() {
        const keys = Object.keys(this._listeners);
        keys.forEach(key => this.unsubscribe(key));
    }
}
//# sourceMappingURL=PostMessageEngine.js.map